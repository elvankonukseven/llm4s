package org.llm4s.llmconnect.model

import upickle.default.{ ReadWriter => RW, macroRW, readwriter, write, read }

/**
 * Represents a message in a conversation with an LLM (Large Language Model).
 */
sealed trait Message {
  def role: String
  def content: String

  override def toString: String = s"${role}: ${content}"
}

/**
 * Represents a user message in the conversation.
 *
 * @param content Content of the user message.
 */
case class UserMessage(content: String) extends Message {
  val role = "user"
}

object UserMessage {
  implicit val rw: RW[UserMessage] = macroRW
}

/**
 * Represents a system message, which is typically used to set context or instructions for the LLM.
 *
 * A system prompt provides the foundational instructions and behavioral guidelines that shape how the
 * LLM should respond to a user request, including its personality, capabilities, constraints, and communication style.
 * It acts as the model's "operating manual," establishing context about what it should and shouldn't do,
 * how to handle various scenarios, and what information it has access to.
 *
 * @param content Content of the system message.
 */
case class SystemMessage(content: String) extends Message {
  val role = "system"
}

object SystemMessage {
  implicit val rw: RW[SystemMessage] = macroRW
}

/**
 * Represents a message from the LLM assistant, which may include text, tool calls or both.
 *
 * @param contentOpt Optional content of the message.
 * @param toolCalls  Sequence of tool calls made by the assistant.
 */
case class AssistantMessage(
  contentOpt: Option[String] = None,
  toolCalls: Seq[ToolCall] = Seq.empty
) extends Message {
  val role = "assistant"

  def content: String = contentOpt.getOrElse("")

  override def toString: String = {
    val toolCallsStr = if (toolCalls.nonEmpty) {
      s"\nTool Calls: ${toolCalls.map(tc => s"[${tc.id}: ${tc.name}(${tc.arguments})]").mkString(", ")}"
    } else " - no tool calls"

    s"${role}: ${content}${toolCallsStr}"
  }
}

object AssistantMessage {
  // Manual ReadWriter for AssistantMessage due to macro issues with default parameters
  implicit val rw: RW[AssistantMessage] = readwriter[ujson.Value].bimap[AssistantMessage](
    msg =>
      ujson.Obj(
        "contentOpt" -> (msg.contentOpt match {
          case None          => ujson.Null
          case Some(content) => ujson.Str(content)
        }),
        "toolCalls" -> ujson.read(write(msg.toolCalls))
      ),
    json => {
      val obj = json.obj
      val contentOpt = obj.get("contentOpt") match {
        case Some(ujson.Null)         => None
        case Some(ujson.Str(content)) => Some(content)
        case _                        => None
      }
      val toolCalls = obj.get("toolCalls") match {
        case Some(toolCallsJson) => read[Seq[ToolCall]](toolCallsJson)
        case _                   => Seq.empty
      }
      AssistantMessage(contentOpt, toolCalls)
    }
  )

  def apply(content: String): AssistantMessage =
    AssistantMessage(Some(content), Seq.empty)
  def apply(content: String, toolCalls: Seq[ToolCall]): AssistantMessage =
    AssistantMessage(Some(content), toolCalls)
}

/**
 * Represents a message from a tool, typically containing the result of a tool call.
 *
 * @param toolCallId Unique identifier for the tool call (as provided by the ToolCall).
 * @param content    Content of the tool message, usually the result of the tool execution, e.g. a json response.
 */
case class ToolMessage(
  toolCallId: String,
  content: String
) extends Message {
  val role = "tool"

  override def toString: String = s"${role}(${toolCallId}): ${content}"
}

object ToolMessage {
  implicit val rw: RW[ToolMessage] = macroRW
}

/**
 * Represents a tool call request from the LLM.
 *
 * @param id Unique identifier for the tool call (generated byt the LLM).
 * @param name Name of the tool being called. (from the list of tools provided to the LLM).
 * @param arguments Arguments passed to the tool in JSON format.
 */
case class ToolCall(
  id: String,
  name: String,
  arguments: ujson.Value
) {
  override def toString: String = s"ToolCall($id, $name, $arguments)"
}

object ToolCall {
  implicit val rw: RW[ToolCall] = macroRW
}

object Message {
  implicit val rw: RW[Message] = readwriter[ujson.Value].bimap[Message](
    {
      case um: UserMessage      => ujson.Obj("type" -> ujson.Str("user"), "content" -> ujson.Str(um.content))
      case sm: SystemMessage    => ujson.Obj("type" -> ujson.Str("system"), "content" -> ujson.Str(sm.content))
      case am: AssistantMessage => ujson.Obj("type" -> ujson.Str("assistant"), "data" -> ujson.read(write(am)))
      case tm: ToolMessage =>
        ujson.Obj(
          "type"       -> ujson.Str("tool"),
          "toolCallId" -> ujson.Str(tm.toolCallId),
          "content"    -> ujson.Str(tm.content)
        )
    },
    json => {
      val obj = json.obj
      obj("type").str match {
        case "user"      => UserMessage(obj("content").str)
        case "system"    => SystemMessage(obj("content").str)
        case "assistant" => read[AssistantMessage](obj("data"))
        case "tool"      => ToolMessage(obj("toolCallId").str, obj("content").str)
      }
    }
  )
}
